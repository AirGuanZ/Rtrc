#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <ranges>
#include <string>

#include <cxxopts.hpp>

#include <Reflection/Frontend.h>

struct Options
{
    std::string sourceFile;
    std::string outputCppReflectionFile;
    std::string outputShaderHeaderFile;
    std::string outputListFile;
};

constexpr auto COMMON_HEADER = R"___(#pragma once

/*==================================================================
    Generated by Rtrc reflection tool. Don't modify this file directly.
==================================================================*/

)___";

std::optional<Options> ParseOptions(int argc, const char *argv[])
{
    cxxopts::Options options("Rtrc.Reflection");
    options.add_options()
        ("i,input", "Input source file",          cxxopts::value<std::string>())
        ("c,cpp",   "Cpp reflection output file", cxxopts::value<std::string>())
        ("s,hlsl",  "Shader header file",         cxxopts::value<std::string>())
        ("l,list",  "List file",                  cxxopts::value<std::string>())
        ("h,help",  "Print usage");

    auto parseResult = options.parse(argc, argv);
    if(parseResult.count("help"))
    {
        std::cout << options.help() << std::endl;
        return std::nullopt;
    }

    Options result;
    if(parseResult.count("input"))
        result.sourceFile = parseResult["input"].as<std::string>();
    if(parseResult.count("cpp"))
        result.outputCppReflectionFile = parseResult["cpp"].as<std::string>();
    if(parseResult.count("hlsl"))
        result.outputShaderHeaderFile = parseResult["hlsl"].as<std::string>();
    if(parseResult.count("list"))
        result.outputListFile = parseResult["list"].as<std::string>();
    return result;
}

std::string GenerateCppReflection(std::span<const Struct> structs)
{
    struct StructRecord
    {
        std::string namespaceName;
        std::string name;
        const Struct *originalStruct = nullptr;
    };
    std::vector<StructRecord> records;

    for(auto &s : structs)
    {
        auto &record = records.emplace_back();

        const std::string &qualifiedName = s.qualifiedName;
        const size_t pos = qualifiedName.rfind("::");
        if(pos != std::string::npos)
        {
            record.namespaceName = qualifiedName.substr(0, pos);
            record.name = qualifiedName.substr(pos + 2);
        }
        else
            record.name = qualifiedName;
        record.originalStruct = &s;
    }

    std::string ret = COMMON_HEADER;
    
    ret += "#include <Rtrc/Math/Vector2.h>\n";
    ret += "#include <Rtrc/Math/Vector3.h>\n";
    ret += "#include <Rtrc/Math/Vector4.h>\n";
    ret += "#include <Rtrc/Math/Matrix4x4.h>\n";

    ret += "\n/*====================== Forward Declarations ======================*/\n\n";

    for(auto &r : records)
    {
        if(!r.namespaceName.empty())
        {
            ret += "namespace " + r.namespaceName + " { ";
            ret += "struct " + r.name + "; }\n";
        }
        else
            ret += "struct " + r.name + ";\n";
    }

    ret += "\n/*====================== Mirror Definitions ======================*/\n\n";

    auto QualifiedNameToMirrorName = [](const std::string &qualifiedName)
    {
        std::string ret = qualifiedName;
        size_t pos = ret.rfind("::");
        if(pos == std::string::npos)
            pos = 0;
        ret.insert(pos + 2, "rtrcReflMirrorStruct_");
        return ret;
    };

    for(auto &r : records)
    {
        std::string namespaceIndent;
        if(!r.namespaceName.empty())
        {
            ret += "namespace " + r.namespaceName + "\n";
            ret += "{\n";
            namespaceIndent = "    ";
        }
        ret += namespaceIndent + "struct rtrcReflMirrorStruct_" + r.name + "\n";
        ret += namespaceIndent + "{\n";

        for(auto &f : r.originalStruct->fields)
        {
            const std::string arrayModifier = f.arraySize ? "[" + std::to_string(*f.arraySize) + "]" : "";
            std::string mirrorTypeStr = f.typeStr;
            if(f.type == FieldType::Others)
                mirrorTypeStr = QualifiedNameToMirrorName(mirrorTypeStr);
            ret += namespaceIndent + "    " + mirrorTypeStr + " " + f.name + arrayModifier + ";\n";
        }

        ret += namespaceIndent + "};\n";
        if(!r.namespaceName.empty())
            ret += "}\n";
    }

    ret += "\n/*====================== Reflection Implementations ======================*/\n\n";

    ret += "namespace Rtrc::ReflectionDetail\n";
    ret += "{\n";
    ret += "    template<typename A, typename B>\n";
    ret += "    struct ReflAux;\n";
    ret += "    template<typename A>\n";
    ret += "    struct MirrorTypeTrait;\n";
    for(auto &s : structs)
    {
        const std::string mirrorName = QualifiedNameToMirrorName(s.qualifiedName);
        ret += "\n";
        ret += "    template<typename B>\n";
        ret += "    struct ReflAux<" + mirrorName + ", B>\n";
        ret += "    {\n";
        ret += "        template<typename F>\n";
        ret += "        static constexpr void ForEachNonStaticMemberVariable(const F &f)\n";
        ret += "        {\n";
        for(auto &f : s.fields)
            ret += "            f(&B::" + f.name + ", \"" + f.name + "\");\n";
        ret += "        }\n";
        ret += "    };\n";
        ret += "    template<>\n";
        ret += "    struct MirrorTypeTrait<" + s.qualifiedName + ">\n";
        ret += "    {\n";
        ret += "        using Type = " + mirrorName + ";\n";
        ret += "    };\n";
    }
    ret += "}\n";

    ret += "\n/*====================== Reflection Entry ======================*/\n\n";

    ret += "namespace Rtrc\n";
    ret += "{\n";
    ret += "    template<typename T>\n";
    ret += "    using Reflection = Rtrc::ReflectionDetail::ReflAux<T, T>;\n";
    ret += "    template<typename T>\n";
    ret += "    using MirrorType = typename Rtrc::ReflectionDetail::MirrorTypeTrait<T>::Type;\n";
    ret += "}\n";

    return ret;
}

std::string GenerateShaderHeader(std::span<const Struct> structs)
{
    std::string ret = COMMON_HEADER;
    
    for(auto &s : structs)
    {
        if(!s.annotations.contains("shader"))
            continue;

        auto segs = std::string_view(s.qualifiedName)
            | std::ranges::views::split(std::string_view("::"))
            | std::ranges::views::transform([](auto &&s) { return std::string(std::string_view(s)); })
            | std::ranges::to<std::vector<std::string>>();
        for(size_t i = 0; i + 1 < segs.size(); ++i)
            ret += "namespace " + segs[i] + " { ";
        std::string indent;
        if(segs.size() > 1)
        {
            ret += "\n";
            indent += "    ";
        }
        ret += indent + "struct " + segs.back() + "\n";
        ret += indent + "{\n";
        for(auto &f : s.fields)
        {
            using enum FieldType;
            std::string type;
            switch(f.type)
            {
            case Float:    type = "float";    break;
            case Float2:   type = "float2";   break;
            case Float3:   type = "float3";   break;
            case Float4:   type = "float4";   break;
            case Int:      type = "int";      break;
            case Int2:     type = "int2";     break;
            case Int3:     type = "int3";     break;
            case Int4:     type = "int4";     break;
            case UInt:     type = "uint";     break;
            case UInt2:    type = "uint2";    break;
            case UInt3:    type = "uint3";    break;
            case UInt4:    type = "uint4";    break;
            case Float4x4: type = "float4x4"; break;
            case Others:   type = f.typeStr;  break;
            }
            const std::string arrayModifier = f.arraySize ? "[" + std::to_string(*f.arraySize) + "]" : "";
            ret += indent + "    " + type + " " + f.name + arrayModifier + ";\n";
        }
        ret += indent + "};\n";
        for(size_t i = 0; i + 1 < segs.size(); ++i)
            ret += "} ";
        ret += "\n";
    }

    return ret;
}

std::string GenerateList(std::span<const Struct> structs)
{
    std::string ret;
    for(auto &s : structs)
    {
        for(auto &anno : s.annotations)
            ret += "TRAVERSE_" + anno + "(" + s.qualifiedName + ")\n";
        ret += "\n";
    }
    return ret;
}

int main(int argc, const char *argv[])
{
    auto options = ParseOptions(argc, argv);
    if(!options)
        return 0;
    
    std::istream *sourceStream;
    std::ifstream fin;
    if(!options->sourceFile.empty())
    {
        fin.open(options->sourceFile, std::ifstream::in);
        if(!fin)
        {
            std::cerr << "Fail to open file: " << options->sourceFile << std::endl;
            return -1;
        }
        sourceStream = &fin;
    }
    else
        sourceStream = &std::cin;

    SourceInfo sources;
    for(std::string line; std::getline(*sourceStream, line);)
    {
        if(line.empty())
            continue;
        if(line.starts_with("source "))
            sources.filenames.push_back(line.substr(7));
        else if(line.starts_with("include "))
            sources.includeDirs.push_back(line.substr(8));
        else
        {
            std::cerr << "Invalid line: " << line << std::endl;
            return -1;
        }
    }

    auto structs = ParseStructs(sources);
    structs.erase(std::remove_if(structs.begin(), structs.end(), [](const Struct &s)
    {
        return !s.annotations.contains("rtrc");
    }), structs.end());

    auto WriteTxt = [](const std::string &filename, const std::string &content)
    {
        auto parentDir = absolute(std::filesystem::path(filename)).parent_path();
        if(!exists(parentDir))
            create_directories(parentDir);

        if(std::ifstream fin2(filename, std::ifstream::in); fin2)
        {
            std::stringstream buffer;
            buffer << fin2.rdbuf();
            if(buffer.str() == content)
                return;
        }
        std::ofstream fout(filename, std::ofstream::out | std::ofstream::trunc);
        if(fout)
            fout << content;
    };
    if(!options->outputCppReflectionFile.empty())
    {
        const std::string content = GenerateCppReflection(structs);
        WriteTxt(options->outputCppReflectionFile, content);
    }
    if(!options->outputShaderHeaderFile.empty())
    {
        const std::string content = GenerateShaderHeader(structs);
        WriteTxt(options->outputShaderHeaderFile, content);
    }
    if(!options->outputListFile.empty())
    {
        const std::string content = GenerateList(structs);
        WriteTxt(options->outputListFile, content);
    }
}
