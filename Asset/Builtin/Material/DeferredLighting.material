Material "Builtin/DeferredLighting"
{
    Pass
    {
        Tag "Default"
        ShaderRef "Builtin/DeferredLighting"
    }
}

Shader "Builtin/DeferredLighting"
{

#vert VSMain
#frag FSMain

#include "Atmosphere.hlsl"
#include "Common/Color.hlsl"
#include "Common/GBuffer.hlsl"
#include "Common/Scene.hlsl"

rtrc_group(Pass)
{
    BUILTIN_INTERNAL_GBUFFERS_FS
    rtrc_define(Texture2D<float3>, SkyLutTexture, FS)
    rtrc_uniform(float4, gbufferSize)
    rtrc_uniform(CameraConstantBuffer, camera)
    rtrc_uniform(DirectionalLightConstantBuffer, directionalLight)
};

rtrc_sampler(SkyLutSampler, filter = linear, address_u = repeat, address_v = clamp)

rtrc_group(TestGroup) // Unused
{
    rtrc_bindless(Texture3D<float4>[256], BindlessArray1)
    rtrc_bindless_varsize(Texture2D<float4>[256], BindlessArray2)
};

struct VsInput
{
    float2 position : POSITION;
    float2 uv       : UV;
    float3 ray      : WORLD_RAY;
};

struct VsToFs
{
    float4 position : SV_POSITION;
    float2 uv       : UV;
    float3 ray      : WORLD_RAY;
};

VsToFs VSMain(VsInput input)
{
    VsToFs output;
    output.position = float4(input.position, 1, 1);
    output.uv = input.uv;
    output.ray = input.ray;
    return output;
}

float4 FSMain(VsToFs input) : SV_TARGET
{
    Builtin::GBufferPixelValue gbuffer = Builtin::LoadGBufferPixel(input.uv);
    float3 color;
    if(gbuffer.depth >= 1)
    {
        float3 dir = normalize(input.ray);
        float2 uv = Atmosphere::ComputeSkyLutTexCoord(dir);
        color = SkyLutTexture.SampleLevel(SkyLutSampler, uv, 0);
    }
    else
    {
        float cosFactor = max(0, dot(gbuffer.normal, -Pass.directionalLight.direction));
        color = 0.01 + cosFactor * Pass.directionalLight.color * Pass.directionalLight.intensity;
        color *= gbuffer.albedo;
    }
    color = Tonemap(color);
    color = pow(color, 1 / 2.2);
    color = Dither01(color, input.uv);
    return float4(color, 1);
}

} // Shader "Builtin/DeferredLighting"
